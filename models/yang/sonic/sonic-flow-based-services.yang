module sonic-flow-based-services {
    namespace "http://github.com/Azure/sonic-flow-based-services";
    prefix sfbs;
    yang-version 1.1;

    import ietf-inet-types {
        prefix inet;
    }

    import sonic-extension {
        prefix sonic-ext;
    }

    import sonic-acl {
        prefix sacl;
    }

    import sonic-port {
        prefix sprt;
    }

    import sonic-portchannel {
        prefix spc;
    }

    import sonic-vlan {
        prefix svlan;
    }

    import sonic-mirror-session {
        prefix sms;
    }

    organization
        "SONiC";

    contact
        "SONiC";

    description
        "SONIC Flow Based Services";

    revision 2020-02-26 {
        description
            "Initial revision.";
    }

    typedef classifier-match-type {
        type enumeration {
            enum FIELDS;
            enum ACL;
        }
    }

    typedef policy-types {
        type enumeration {
            enum QOS;
            enum MONITORING;
            enum FORWARDING;
        }
    }

    typedef policy-binding-stages {
        type enumeration {
            enum INGRESS;
            enum EGRESS;
        }
    }

    grouping classifier-attributes {
        leaf DESCRIPTION {
            type string {
                length 1..256 {
                    error-app-tag policy-description-invalid-length;
                }
            }
        }

        leaf MATCH_TYPE {
            type classifier-match-type;
            mandatory true;
            sonic-ext:custom-validation ValidateLeafConstant;
        }

        leaf ACL_NAME {
            type leafref {
                path "/sacl:sonic-acl/sacl:ACL_TABLE/sacl:ACL_TABLE_LIST/sacl:aclname";
            }
            when "current()/../MATCH_TYPE = 'ACL'";
            sonic-ext:custom-validation ValidateLeafConstant;
        }

        leaf ACL_TYPE {
            type enumeration {
                enum L2;
                enum L3;
                enum L3V6;
            }
            when "current()/../MATCH_TYPE = 'ACL'";
            /*must "/sacl:sonic-acl/sacl:ACL_TABLE/sacl:ACL_TABLE_LIST[sacl:aclname=current()/../ACL_NAME]/type = current()" {
                error-app-tag acl-type-mismatch;
                error-message "ACL type is not same as input";
            }*/
            sonic-ext:custom-validation ValidateLeafConstant;
        }

        leaf ETHER_TYPE {
            type string {
                pattern "0[xX][6-9a-fA-F][0-9a-fA-F]{2,3}|0[xX][1-9a-fA-F][0-9a-fA-F]{3,4}" {
                    error-message "Invalid Ether Type";
                    error-app-tag ether-type-invalid;
                }
            }
            when "current()/../MATCH_TYPE = 'FIELDS'";
        }

        leaf SRC_MAC {
            type string {
                pattern "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}|[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}/[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}";
            }
            when "current()/../MATCH_TYPE = 'FIELDS'";
        }

        leaf DST_MAC {
            type string {
                pattern "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}|[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}/[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}";
            }
            when "current()/../MATCH_TYPE = 'FIELDS'";
        }

        leaf VLAN {
            type uint16 {
                range "1..4094" {
                    error-app-tag vlanid-invalid;
                    error-message "Vlan ID out of range";
                }
            }
            when "current()/../MATCH_TYPE = 'FIELDS'";
        }

        leaf PCP {
            type uint8 {
                range "0..7" {
                    error-app-tag invalid-pcp-value;
                    error-message "Invalid PCP Value.";
                }
            }
            when "current()/../MATCH_TYPE = 'FIELDS'";
        }

        leaf DEI {
            type uint8 {
                range "0..1" {
                    error-app-tag invalid-dei-value;
                    error-message "Invalid DEI Value.";
                }
            }
            when "current()/../MATCH_TYPE = 'FIELDS'";
        }

        leaf IP_PROTOCOL {
            type uint8;
            when "current()/../MATCH_TYPE = 'FIELDS'";
            must "((translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x800') or ((translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x86dd')) or (not(current()/../ETHER_TYPE)))" {
                error-app-tag ethertype-not-ipv4-ipv6;
                error-message "IP Protocol can be configured only when Ethertype is IPv4 or IPv6";
            }
        }

        leaf SRC_IP {
            type inet:ipv4-prefix;
            when "current()/../MATCH_TYPE = 'FIELDS'";
            must "(not(current()/../SRC_IPV6)) and (not(current()/../DST_IPV6))" {
                error-message "Configuring IPv4 and IPv6 header fields in the same classifier is not allowed.";
            }
            must "(translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x800') or (not(current()/../ETHER_TYPE))" {
                error-app-tag src-ip-ethertype-not-ipv4;
                error-message "Source IP address can be configured only when ethertype is IPv4";
            }
        }

        leaf DST_IP {
            type inet:ipv4-prefix;
            when "current()/../MATCH_TYPE = 'FIELDS'";
            must "(not(current()/../SRC_IPV6)) and (not(current()/../DST_IPV6))" {
                error-message "Configuring IPv4 and IPv6 header fields in the same classifier is not allowed.";
            }
            must "(translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x800') or (not(current()/../ETHER_TYPE))" {
                error-app-tag dst-ip-ethertype-not-ipv4;
                error-message "Destination IP address can be configured only when ethertype is IPv4";
            }
        }

        leaf SRC_IPV6 {
            type inet:ipv6-prefix;
            when "current()/../MATCH_TYPE = 'FIELDS'";
            must "(not(current()/../SRC_IP)) and (not(current()/../DST_IP))" {
                error-message "Configuring IPv4 and IPv6 header fields in the same classifier is not allowed.";
            }
            must "(translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x86dd') or (not(current()/../ETHER_TYPE))" {
                error-app-tag src-ip-ethertype-not-ipv6;
                error-message "Source IPv6 address can be configured only when ethertype is IPv6";
            }
        }

        leaf DST_IPV6 {
            type inet:ipv6-prefix;
            when "current()/../MATCH_TYPE = 'FIELDS'";
            must "(not(current()/../SRC_IP)) and (not(current()/../DST_IP))" {
                error-message "Configuring IPv4 and IPv6 header fields in the same classifier is not allowed.";
            }
            must "(translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x86dd') or (not(current()/../ETHER_TYPE))" {
                error-app-tag dst-ip-ethertype-not-ipv6;
                error-message "Destination IPv6 address can be configured only when ethertype is IPv6";
            }
        }

        leaf DSCP {
            type uint8 {
                range "0..63" {
                    error-app-tag invalid-dscp-value;
                    error-message "Invalid DSCP Value.";
                }
            }
            when "current()/../MATCH_TYPE = 'FIELDS'";
            must "((translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x800') or ((translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x86dd')) or (not(current()/../ETHER_TYPE)))" {
                error-app-tag ethertype-not-ipv4-ipv6;
                error-message "IP Protocol can be configured only when Ethertype is IPv4 or IPv6";
            }
        }

        choice src_port {
            when "current()/MATCH_TYPE = 'FIELDS'";
            case l4_src_port {
                leaf L4_SRC_PORT {
                    type uint16;
                    must "((current()/../IP_PROTOCOL = 6) or (current()/../IP_PROTOCOL = 17))" {
                        error-app-tag ip-protocol-not-tcp-or-udp;
                        error-message "Layer 4 source port can be configured only when IP protocol is TCP or UDP";
                    }
                    must "((translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x800') or ((translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x86dd')) or (not(current()/../ETHER_TYPE)))" {
                        error-app-tag ethertype-not-ipv4-ipv6;
                        error-message "TCP/UDP ports can be configured only when Ethertype is IPv4 or IPv6";
                    }
                }
            }
            case l4_src_port_range {
                leaf L4_SRC_PORT_RANGE {
                    type string {
                        pattern "([0-9]{1,4}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])(-)([0-9]{1,4}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])";
                    }
                    must "((current()/../IP_PROTOCOL = 6) or (current()/../IP_PROTOCOL = 17))" {
                        error-app-tag ip-protocol-not-tcp-or-udp;
                        error-message "Layer 4 source port can be configured only when IP protocol is TCP or UDP";
                    }
                    must "((translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x800') or ((translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x86dd')) or (not(current()/../ETHER_TYPE)))" {
                        error-app-tag ethertype-not-ipv4-ipv6;
                        error-message "TCP/UDP ports can be configured only when Ethertype is IPv4 or IPv6";
                    }
                }
            }
        }

        choice dst_port {
            when "current()/MATCH_TYPE = 'FIELDS'";
            case l4_dst_port {
                leaf L4_DST_PORT {
                    type uint16;
                    must "((current()/../IP_PROTOCOL = 6) or (current()/../IP_PROTOCOL = 17))" {
                        error-app-tag ip-protocol-not-tcp-or-udp;
                        error-message "Layer 4 source port can be configured only when IP protocol is TCP or UDP";
                    }
                    must "((translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x800') or ((translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x86dd')) or (not(current()/../ETHER_TYPE)))" {
                        error-app-tag ethertype-not-ipv4-ipv6;
                        error-message "TCP/UDP ports can be configured only when Ethertype is IPv4 or IPv6";
                    }
                }
            }
            case l4_dst_port_range {
                leaf L4_DST_PORT_RANGE {
                    type string {
                        pattern "([0-9]{1,4}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])(-)([0-9]{1,4}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])";
                    }
                    must "((current()/../IP_PROTOCOL = 6) or (current()/../IP_PROTOCOL = 17))" {
                        error-app-tag ip-protocol-not-tcp-or-udp;
                        error-message "Layer 4 source port can be configured only when IP protocol is TCP or UDP";
                    }
                    must "((translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x800') or ((translate(current()/../ETHER_TYPE, 'ABCDEFX', 'abcdefx') = '0x86dd')) or (not(current()/../ETHER_TYPE)))" {
                        error-app-tag ethertype-not-ipv4-ipv6;
                        error-message "TCP/UDP ports can be configured only when Ethertype is IPv4 or IPv6";
                    }
                }
            }
        }

        leaf TCP_FLAGS {
            when "current()/../MATCH_TYPE = 'FIELDS'";
            must "current()/../IP_PROTOCOL = 6" {
                error-app-tag ip-protocol-not-tcp;
                error-message "TCP Flags can be configured only when IP protocol is IP protocol is TCP";
            }

            type string {
                pattern "(0[xX][1-9a-fA-F][0-9a-fA-F]?|[1-9][0-9]?|1[0-9]{2}|2[0-5]{2})/(0[xX][1-9a-fA-F][0-9a-fA-F]?|[1-9][0-9]?|1[0-9]{2}|2[0-5]{2})";
            }
        }
        /*
        leaf ICMP_TYPE {
            when "current()/../MATCH_TYPE = 'FIELDS'";
            type uint8;
            must "((current()/../IP_PROTOCOL = 1) or (current()/../IP_PROTOCOL = 58))" {
                error-app-tag ip-protocol-not-icmp-or-icmpv6;
                error-message "ICMP type can be configured only when IP protocol is ICMP or ICMPv6";
            }
        }

        leaf ICMP_CODE {
            when "current()/../MATCH_TYPE = 'FIELDS'";
            must "((current()/../IP_PROTOCOL = 1) or (current()/../IP_PROTOCOL = 58))" {
                error-app-tag ip-protocol-not-icmp-or-icmpv6;
                error-message "ICMP code can be configured only when IP protocol is ICMP or ICMPv6";
            }
            type uint8;
        }
        */
    }

    grouping policy-section-attributes {
        leaf DESCRIPTION {
            type string {
                length 1..256 {
                    error-app-tag policy-description-invalid-length;
                }
            }
        }

        leaf PRIORITY {
            type uint16 {
                range "0..4095" {
                    error-app-tag invalid-priority;
                }
            }
            mandatory true;
            sonic-ext:custom-validation ValidateLeafConstant;
        }
    }

    grouping policy-section-qos-actions {
        leaf SET_DSCP {
            type uint8 {
                range "0..63" {
                    error-app-tag invalid-dscp-value;
                    error-message "Invalid DSCP value.";
                }
            }
        }

        leaf SET_PCP {
            type uint8 {
                range "0..7" {
                    error-app-tag invalid-pcp-value;
                    error-message "Invalid PCP value.";
                }
            }
        }

        leaf SET_TC {
            type uint8 {
                range "0..7" {
                    error-app-tag invalid-traffic-class-value;
                    error-message "Invalid Traffic Class value.";
                }
            }
        }

        leaf SET_POLICER_CIR {
            type uint64;
            units bps;
        }

        leaf SET_POLICER_CBS {
            type uint64;
            units bytes;
            must "(current()/../SET_POLICER_CIR) and (current()/../SET_POLICER_CIR > 0)" {
                error-app-tag cir-not-configured;
                error-message "CBS can't be configured without CIR.";
            }
            must "current()*8 >= current()/../SET_POLICER_CIR" {
                error-app-tag cbs-less-than-cir;
                error-message "CBS must be greater than or equal to CIR";
            }
        }

        leaf SET_POLICER_PIR {
            type uint64;
            units bps;
            must "(current()/../SET_POLICER_CIR) and (current()/../SET_POLICER_CIR > 0)" {
                error-app-tag cir-not-configured;
                error-message "PIR can't be configured without CIR.";
            }
            must "current() >= current()/../SET_POLICER_CIR" {
                error-app-tag pir-less-than-cir;
                error-message "PIR must be greater than or equal to CIR";
            }
        }

        leaf SET_POLICER_PBS {
            type uint64;
            units bytes;
            must "(current()/../SET_POLICER_PIR) and (current()/../SET_POLICER_PIR > 0)" {
                error-app-tag pir-not-configured;
                error-message "PBS can't be configured without PIR.";
            }
            must "current()*8 >= current()/../SET_POLICER_PIR" {
                error-app-tag pbs-less-than-pir;
                error-message "PBS must be greater than or equal to PIR";
            }
            must "(not(current()/../SET_POLICER_CBS)) or (current() >= current()/../SET_POLICER_CBS)" {
                error-app-tag pbs-less-than-cbs;
                error-message "PBS must be greater than or equal to CBS";
            }
        }
    }

    grouping policy-section-mirror-actions {
        leaf SET_MIRROR_SESSION {
            type leafref {
                path "/sms:sonic-mirror-session/sms:MIRROR_SESSION/sms:MIRROR_SESSION_LIST/sms:name";
            }
        }
    }

    grouping policy-section-actions {
        choice flow-actions {
            case qos-actions {
                description "All QoS actions for QoS policies";
                when "/sonic-flow-based-services/POLICY_TABLE/POLICY_TABLE_LIST[POLICY_NAME=current()/POLICY_NAME]/TYPE = 'QOS'";
                uses policy-section-qos-actions;
            }

            case monitoring-actions {
                description "All monitoring actions for monitoring policies";
                when "/sonic-flow-based-services/POLICY_TABLE/POLICY_TABLE_LIST[POLICY_NAME=current()/POLICY_NAME]/TYPE = 'MONITORING'";
                uses policy-section-mirror-actions;
            }

            case forwarding-options {
                description "All forwarding actions for forwarding policies";
                when "/sonic-flow-based-services/POLICY_TABLE/POLICY_TABLE_LIST[POLICY_NAME=current()/POLICY_NAME]/TYPE = 'FORWARDING'";
                choice egress-options {
                    case l2-egress-option {
                        description "Egress options for L2 forwarding. Each leaf is in the format <PortName>|<Priority>.
                            Priority can be empty as its optional";
                        leaf-list SET_INTERFACE {
                            max-elements 64;
                            type string {
                                pattern '((Ethernet([1-3][0-9]{3}|[1-9][0-9]{2}|[1-9][0-9]|[0-9]))|(PortChannel([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-6])))\|'
                                    + '([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])?';
                            }
                            sonic-ext:custom-validation ValidateSetInterfaceConfig;
                        }
                    }
                    case ipv4-egress-option {
                        description "Egress options for IPv4 forwarding. Each leaf is in the format <IPv4Address>|<VRF>|<Priority>.
                            Priority and VRF can be empty as its optional";
                        leaf-list SET_IP_NEXTHOP {
                            max-elements 64;
                            type string {
                                pattern '((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))\|'
                                    + '(default|Vrf[a-zA-Z0-9_-]+)?\|'
                                    + '([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])?';
                            }
                            sonic-ext:custom-validation ValidateSetIPvxNextHopConfig;
                        }
                    }
                    case ipv6-egress-option {
                        description "Egress options for IPv6 forwarding. Each leaf is in the format <IPv6Address>|<VRF>|<Priority>.
                            Priority and VRF can be empty as its optional";
                        leaf-list SET_IPV6_NEXTHOP {
                            max-elements 64;
                            type string {
                                pattern '(((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}(([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4})))\|'
                                    + '(default|Vrf[a-zA-Z0-9_-]+)?\|'
                                    + '([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])?';
                            }
                            sonic-ext:custom-validation ValidateSetIPvxNextHopConfig;
                        }
                    }
                }

                leaf DEFAULT_PACKET_ACTION {
                    type enumeration {
                        enum DROP;
                    }
                }
            }
        }
    }

    grouping policy-attributes {
        leaf DESCRIPTION {
            type string {
                length 1..256 {
                    error-app-tag policy-description-invalid-length;
                }
            }
        }

        leaf TYPE {
            type policy-types;
            mandatory true;
            sonic-ext:custom-validation ValidateLeafConstant;
        }
    }

    container sonic-flow-based-services {
        container POLICY_TABLE {
            list POLICY_TABLE_LIST {
                key "POLICY_NAME";
                max-elements 256;

                leaf POLICY_NAME {
                    type string {
                        pattern '[a-zA-Z0-9]{1}([-a-zA-Z0-9_]{0,62})';
                        length 1..63;
                    }
                }

                leaf DESCRIPTION {
                    type string {
                        length 1..256 {
                            error-app-tag policy-description-invalid-length;
                        }
                    }
                }

                leaf TYPE {
                    mandatory true;
                    sonic-ext:custom-validation ValidateLeafConstant;
                    type policy-types;
                }
            }
        }

        container CLASSIFIER_TABLE {
            list CLASSIFIER_TABLE_LIST {
                key "CLASSIFIER_NAME";
                max-elements 256;

                leaf CLASSIFIER_NAME {
                    type string {
                        pattern '[a-zA-Z0-9]{1}([-a-zA-Z0-9_]{0,62})';
                        length 1..63;
                    }

                    must "current() != 'default'" {
                        error-app-tag name-not-allowed;
                        error-message "'default' name is not allowed";
                    }
                }

                uses classifier-attributes;
            }
        }

        container POLICY_SECTIONS_TABLE {
            list POLICY_SECTIONS_TABLE_LIST {
                key "POLICY_NAME CLASSIFIER_NAME";

                leaf POLICY_NAME {
                    type leafref {
                        path "/sonic-flow-based-services/POLICY_TABLE/POLICY_TABLE_LIST/POLICY_NAME";
                    }
                }

                leaf CLASSIFIER_NAME {
                    type leafref {
                        path "/sonic-flow-based-services/CLASSIFIER_TABLE/CLASSIFIER_TABLE_LIST/CLASSIFIER_NAME";
                    }
                }

                uses policy-section-attributes;
                uses policy-section-actions;
            }
        }

        container POLICY_BINDING_TABLE {
            list POLICY_BINDING_TABLE_LIST {
                key INTERFACE_NAME;

                leaf INTERFACE_NAME {
                    type union {
                        type leafref {
                            path "/sprt:sonic-port/sprt:PORT/sprt:PORT_LIST/sprt:ifname";
                        }
                        type leafref {
                            path "/spc:sonic-portchannel/spc:PORTCHANNEL/spc:PORTCHANNEL_LIST/spc:name";
                        }
                        type leafref {
                            path "/svlan:sonic-vlan/svlan:VLAN/svlan:VLAN_LIST/svlan:name";
                        }
                        type string {
                            pattern "Switch";
                        }
                    }
                }

                leaf INGRESS_QOS_POLICY {
                    must "/sonic-flow-based-services/POLICY_TABLE/POLICY_TABLE_LIST[POLICY_NAME=current()]/TYPE = 'QOS'" {
                        error-app-tag policy-not-qos-type;
                        error-message "Policy is not of type qos";
                    }
                    type leafref {
                        path "/sonic-flow-based-services/POLICY_TABLE/POLICY_TABLE_LIST/POLICY_NAME";
                    }
                    sonic-ext:custom-validation ValidateLeafConstant;
                }
                leaf EGRESS_QOS_POLICY {
                    must "/sonic-flow-based-services/POLICY_TABLE/POLICY_TABLE_LIST[POLICY_NAME=current()]/TYPE = 'QOS'" {
                        error-app-tag policy-not-qos-type;
                        error-message "Policy is not of type qos";
                    }
                    type leafref {
                        path "/sonic-flow-based-services/POLICY_TABLE/POLICY_TABLE_LIST/POLICY_NAME";
                    }
                    sonic-ext:custom-validation ValidateLeafConstant;
                }
                leaf INGRESS_MONITORING_POLICY {
                    must "/sonic-flow-based-services/POLICY_TABLE/POLICY_TABLE_LIST[POLICY_NAME=current()]/TYPE = 'MONITORING'" {
                        error-app-tag policy-not-monitoring-type;
                        error-message "Policy is not of type monitoring";
                    }
                    type leafref {
                        path "/sonic-flow-based-services/POLICY_TABLE/POLICY_TABLE_LIST/POLICY_NAME";
                    }
                    sonic-ext:custom-validation ValidateLeafConstant;
                }
                leaf INGRESS_FORWARDING_POLICY {
                    must "/sonic-flow-based-services/POLICY_TABLE/POLICY_TABLE_LIST[POLICY_NAME=current()]/TYPE = 'FORWARDING'" {
                        error-app-tag policy-not-forwarding-type;
                        error-message "Policy is not of type forwarding";
                    }
                    type leafref {
                        path "/sonic-flow-based-services/POLICY_TABLE/POLICY_TABLE_LIST/POLICY_NAME";
                    }
                    sonic-ext:custom-validation ValidateLeafConstant;
                }
            }
        }
    }


    // RPCs related

    // Groupings needed for RPCs
    grouping pbf-egress-intf-config-attributes {
        leaf INTERFACE_NAME {
            type string;
        }

        leaf PRIORITY {
            type uint16;
        }
    }

    grouping pbf-nexthop-config-attributes {
        leaf IP_ADDRESS {
            type string;
        }

        leaf VRF {
            type string;
        }

        leaf PRIORITY {
            type uint16;
        }
    }

    // RPCs
    rpc get-classifier {
        description
            "RPC to retrieve the classifier data. The name and match-type are optional. If no name is specified then all
            classifiers with the matching match-type will be retrieved. If no match-type is provided then all
            classifiers will be retrieved.";

        input {
            leaf CLASSIFIER_NAME {
                type string;
                description
                    "Classifier Name to be retrieved. (Optional)";
            }
            leaf MATCH_TYPE {
                type classifier-match-type;
                description
                    "Retrieve the classifier using match-type.";
            }
        }
        output {
            list CLASSIFIERS {
                key "CLASSIFIER_NAME";

                leaf CLASSIFIER_NAME {
                    type string;
                    description
                        "Classifier name";
                }

                uses classifier-attributes;

                list REFERENCES {
                    leaf POLICY_NAME {
                        type string;
                        description
                            "Policy name referring this classifier";
                    }
                    uses policy-section-attributes;
                }
            }
        }
    }

    rpc get-policy {
        description
            "RPC to retrieve the policy data. The name and type are optional. If no name is specified then all
            policies with the matching type will be retrieved. If no type is provided then all policies will
            be retrieved.";

        input {
            leaf POLICY_NAME {
                type string;
                description
                    "Name of the policy to retrieved. (Optional)";
            }
            leaf TYPE {
                type policy-types;
                description
                    "Type of the policy to retrieved. (Optional)";
            }
        }
        output {
            list POLICIES {
                key "POLICY_NAME";

                leaf POLICY_NAME {
                    type string;
                }

                uses policy-attributes;

                list FLOWS {
                    leaf CLASS_NAME {
                        type string;
                        description
                            "Classifier using this policy";
                    }

                    uses policy-section-attributes;
                    uses policy-section-qos-actions;
                    uses policy-section-mirror-actions;

                    list SET_INTERFACE {
                        uses pbf-egress-intf-config-attributes;
                    }

                    list SET_IP_NEXT_HOP {
                        uses pbf-nexthop-config-attributes;
                    }

                    list SET_IPV6_NEXT_HOP {
                        uses pbf-nexthop-config-attributes;
                    }

                    leaf DEFAULT_PACKET_ACTION {
                        type enumeration {
                            enum DROP;
                        }
                    }
                }

                list APPLIED_INTERFACES {
                    leaf INTERFACE_NAME {
                        type string;
                        description
                            "Interface name on which the policy is applied.";
                    }

                    leaf STAGE {
                        type policy-binding-stages;
                        description
                            "Policy binding direction ingress/egress";
                    }
                }
            }
        }
    }

    rpc get-service-policy {
        description
            "Reprieves the Operational state of the policy application on interface like match counters,
            policer counters for QoS policies, selected next-hop for forwarding policies etc. Policy name or
            Interface name is mandatory. The following list shows the different combination supported

            Policy Name only:: Operational data for all applications of the policy
            Intf Name only:: Operational data for all policies applied for the interface.
            Type only:: Not supported.
            Policy Name + Intf Name:: Operational data for specific application of the policy to interface.
            Policy Name + Type:: Same as specifying just policy name but with added validation for type match.
            Intf Name + Type:: Operational data for specified policy type on the interface.
            Policy Name + Intf Name + Type:: Same as Policy Name + Intf Name but added validation for type match.";

        input {
            leaf POLICY_NAME {
                type string;
                description
                    "Name of the policy to retrieved.";
            }
            leaf INTERFACE_NAME {
                type string;
                description
                    "Interface name on which the policy is applied.";
            }
            leaf TYPE {
                type policy-types;
                description
                    "Type of the policy to retrieved. (Optional)";
            }
        }
        output {
            list INTERFACES {
                key "INTERFACE_NAME";

                leaf INTERFACE_NAME {
                    type string;
                }

                list APPLIED_POLICIES {
                    leaf POLICY_NAME {
                        type string;
                    }

                    leaf STAGE {
                        type policy-binding-stages;
                        description
                            "Policy binding direction ingress/egress";
                    }

                    uses policy-attributes;

                    list FLOWS {
                        leaf CLASS_NAME {
                            type string;
                            description
                                "Classifier using this policy";
                        }

                        uses policy-section-attributes;
                        uses policy-section-qos-actions;
                        uses policy-section-mirror-actions;

                        list SET_INTERFACE {
                            uses pbf-egress-intf-config-attributes;
                        }

                        list SET_IP_NEXT_HOP {
                            uses pbf-nexthop-config-attributes;
                        }

                        list SET_IPV6_NEXT_HOP {
                            uses pbf-nexthop-config-attributes;
                        }

                        leaf DEFAULT_PACKET_ACTION {
                            type enumeration {
                                enum DROP;
                            }
                        }

                        container STATE {
                            leaf STATUS {
                                type enumeration {
                                    enum Active;
                                    enum Inactive;
                                }
                                description
                                    "Policy bind status Active/Inactive";
                            }

                            leaf MATCHED_PACKETS {
                                type uint64;
                                description
                                    "Number of packets that matched the flow classification criteria";
                            }

                            leaf MATCHED_BYTES {
                                type uint64;
                                description
                                    "Number of bytes that matched the flow classification criteria";
                            }

                            container POLICER {
                                leaf CONFORMED_PACKETS {
                                    type uint64;
                                    description
                                        "matching green packet count for policier counters";
                                }
                                leaf CONFORMED_BYTES {
                                    type uint64;
                                    description
                                        "matching green packet count for policier counters";
                                }
                                leaf EXCEED_PACKETS {
                                    type uint64;
                                    description
                                        "matching yellow packet count for policier counters";
                                }
                                leaf EXCEED_BYTES {
                                    type uint64;
                                    description
                                        "matching yellow packet count for policier counters";
                                }
                                leaf VIOLATED_PACKETS {
                                    type uint64;
                                    description
                                        "matching red packet count for policier counters";
                                }
                                leaf VIOLATED_BYTES {
                                    type uint64;
                                    description
                                        "matching red packet count for policier counters";
                                }
                                leaf CONFORMED_PACKET_ACTION {
                                    type string;
                                    description
                                        "green packet action";
                                }
                                leaf EXCEED_PACKET_ACTION {
                                    type string;
                                    description
                                        "yellow packet action";
                                }
                                leaf VIOLATED_PACKET_ACTION {
                                    type string;
                                    description
                                        "red packet action";
                                }
                                leaf OPERATIONAL_CIR {
                                    type uint64;
                                }
                                leaf OPERATIONAL_CBS {
                                    type uint64;
                                }
                                leaf OPERATIONAL_PIR {
                                    type uint64;
                                }
                                leaf OPERATIONAL_PBS {
                                    type uint64;
                                }

                                leaf UNITS {
                                    type enumeration {
                                        enum BYTES;
                                    }
                                }

                                leaf COLOR_SOURCE {
                                    type enumeration {
                                        enum COLOR-BLIND;
                                    }
                                }

                                leaf STATUS {
                                    type enumeration {
                                        enum Active;
                                        enum Inactive;
                                    }
                                }
                            }

                            container FORWARDING_SELECTED {
                                leaf PACKET_ACTION {
                                    type enumeration {
                                        enum DROP;
                                    }
                                }
                                leaf INTERFACE_NAME {
                                    type string;
                                }

                                leaf IP_ADDRESS {
                                    type string;
                                }

                                leaf VRF {
                                    type string;
                                }

                                leaf PRIORITY {
                                    type uint16;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    rpc clear-service-policy-counters {
        description
            "Clear the countes associated with the policy like Match counters and Policer counters etc.
            Policy name or Interface name is mandatory. The following list shows the different combination supported

            Policy Name only:: Clear counters for all applications of this policy
            Intf Name only:: Clear counters for all policies applied for the interface.
            Type only:: Not supported.
            Policy Name + Intf Name:: Clear counters for specific application of the policy to interface.
            Policy Name + Type:: Same as specifying just policy name but with added validation for type match.
            Intf Name + Type:: Clear counters for specified policy type on the interface.
            Policy Name + Intf Name + Type:: Same as Policy Name + Intf Name but added validation for type match.";

        input {
            leaf POLICY_NAME {
                type string;
                description
                    "Name of the policy to retrieved.";
            }
            leaf INTERFACE_NAME {
                type string;
                description
                    "Interface name on which the policy is applied.";
            }
            leaf TYPE {
                type policy-types;
                description
                    "Type of the policy to retrieved. (Optional)";
            }
        }
    }
}
